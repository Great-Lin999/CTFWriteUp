# [BUUCTF]RSA3

## 解题思路

### RSA的共模攻击

- 生成`RSA`私钥时，使用的质数`p`和`q`并没有进行变化，生成的`模n`也没有变化，使用同一个`模n`生成了多个`公私钥`对。
    - 比如在同一家公司中，使用同一个`模n`生成两对`公私钥对`，分发给`A`和`B`。然后老板用他们各自的公钥对`同一份文件`进行了加密。
    - 当攻击者可以拿到`n、PKa、PKb、密文A、密文B`的情况下，就可以解出`密文`
    - 具体的数学推导过程，[详见](https://www.cnblogs.com/gwind/p/8013154.html)。即存在`s1,s2`有`e1s1+e2s2=1`，则`m = (c1^s1 * c2^s2) %n`

### 解题过程

1. 题目下载下来为一个`txt`文件，根据文件中提供的变量名：`n、c1、c2、e1、e2`，有`模n`，有两个`c`，可以采用`共模攻击`
```
from gmpy2 import invert
def gongmo(n, c1, c2, e1, e2):
    s1,s2 = egcd(e1, e2)
    # 如果获得的s1,s2为负数，进行模反操作
    if s1<0:
        s1 = - s1
        c1 = invert(c1, n)
    elif s2<0:
        s2 = - s2
        c2 = invert(c2, n)

    m = pow(c1,s1,n)*pow(c2,s2,n) % n
    return m
# 扩展的欧几里得算法
def egcd(a, b):
    if b == 0:
        return a, 0
    else:
        x,y = egcd(b, a % b)
        return y, x - (a // b) * y


if __name__ == "__main__":
    c1=22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361
    n=22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801
    e1=11187289
    c2=18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397
    e2=9647291
    m=gongmo(n, c1, c2, e1, e2)
    print(m)
```
2. 结出来的`m`为：`13040004482819947212936436796507286940525898188874967465457845309271472287032383337801279101`
3. 感觉是十进制，转化成`16`进制时发现了`0x`
4. 再由`16`进制转换成`ascii`，发现了`flag`
## 参考资料

- [RSA-共模推导](https://www.cnblogs.com/gwind/p/8013154.html)

- [python3.9中安装gmpy2](https://www.cnblogs.com/newcomer/p/14125031.html)